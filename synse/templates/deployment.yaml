apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ template "fullname" . }}
  labels:
{{ include "labels" . | indent 4 }}
  annotations:
{{ include "annotations" . | indent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
{{ include "selector" . | indent 6 }}
  template:
    metadata:
      name: {{ template "fullname" . }}
      labels:
{{ include "labels" . | indent 8 }}
      annotations:
{{ include "annotations" . | indent 8 }}
    spec:
      containers:
      - name: {{ .Chart.Name }}
        image: "{{ .Values.image.registry }}{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        ports:
          - name: http
            containerPort: {{ .Values.service.port }}
            hostPort: {{ .Values.service.port }}
            protocol: TCP
        # TODO: We need to add these
        # livenessProbe:
        #   httpGet:
        #     path: /
        #     port: http
        # readinessProbe:
        #   httpGet:
        #     path: /
        #     port: http
        # TODO: Make all of this suck less (aka dynamic)
        env:
            - name: NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
            - name: POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: SYNSE_DEBUG
              value: "true"
            # Register all I2C Plugins in a Chamber (1 per VEC, for a total of
            # 6) with Synse Server. I2C plugins are currently a StatefulSet with
            # a headless Service - while their IP may change if they go down/up
            # this setup allows us to reference them via kube DNS in the format:
            #   {pod name}.{service name}.{namespace}.svc.cluster.local
            - name: SYNSE_PLUGIN_TCP_I2C0
              value: {{ .Release.Name }}-i2c-0.{{ .Release.Name }}-i2c.default.svc.cluster.local:5002
            - name: SYNSE_PLUGIN_TCP_I2C1
              value: {{ .Release.Name }}-i2c-1.{{ .Release.Name }}-i2c.default.svc.cluster.local:5002
            - name: SYNSE_PLUGIN_TCP_I2C2
              value: {{ .Release.Name }}-i2c-2.{{ .Release.Name }}-i2c.default.svc.cluster.local:5002
            - name: SYNSE_PLUGIN_TCP_I2C3
              value: {{ .Release.Name }}-i2c-3.{{ .Release.Name }}-i2c.default.svc.cluster.local:5002
            - name: SYNSE_PLUGIN_TCP_I2C4
              value: {{ .Release.Name }}-i2c-4.{{ .Release.Name }}-i2c.default.svc.cluster.local:5002
            - name: SYNSE_PLUGIN_TCP_I2C5
              value: {{ .Release.Name }}-i2c-5.{{ .Release.Name }}-i2c.default.svc.cluster.local:5002
            # Register the RS458 plugin with Synse Server. There is only one
            # instance of the plugin per Chamber in order to prevent bus collisions.
            # The RS485 pod sits behind an RS485 service, which we reference here to
            # access the pod.
            - name: SYNSE_PLUGIN_TCP_RS485
              value: {{ .Release.Name }}-rs485:5001
        {{ if .Values.resources }}
        resources:
{{ toYaml .Values.resources | indent 12 }}
        {{ end }}
